//////////////////////////////////////////////////////////
// [다양한 입출력 방식]
//////////////////////////////////////////////////////////

// [ 프로그램 입출력 ] /////////////////////////////////////

// 프로그램 입출력은 기본적으로 프로그램 속 명령어로 입출력장치를 제어하는 방법이다.

// 메모리가 저장된 정보를 백업하는 과정을 살펴보자.CPU는 대략적으로 아래와 같은 과정으로 입출력 작업을 한다.

// 1. 메모리에 저장된 정보를 하드 디스크에 백업한다. == 하드 디스크에 새로운 정보를 쓴다.
// 우선 CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령을 보낸다.

// 2. 하드 디스크 컨트롤러는 하드 디스크 상태를 확인한다.준비된 상태라면 하드 디스크 컨트롤러는 상태 레지스터에 준비되었다고 표시한다.

// 3. 1) CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인한다. 2) 하드 디스크가 준비됐음을 CPU가 알게 되면 백업할 메모리 정보를 데이터 레지스터에 쓴다.

// 4. 백업 작업(쓰기 작업)이 끝나지 않았다면 1번부터 반복, 쓰기가 끝났다면 작업을 종료한다.

// 이처럼 입출력 작업은 CPU가 장치 컨트롤러의 레지스터의 값을 읽고 씀으로써 이뤄진다.여기서 CPU가 장치 컨트롤러의 레지스터를 찾는 방식은 크게 두 방식이 있다.

// ## 메모리 맵 입출력 //////////////////////////////////////

// 메모리 맵 입출력은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법이다.

// 가령 1024개의 주소를 표현할 수 있는 컴퓨터가 있을 때, 512개는 메모리 주소를, 512개는 장치 컨트롤러의 레지스터를 표현하기 위해 사용한다.

// 메모리 맵 입출력 방식에서 CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같은 메모리 주소를 대하듯 접근하면 된다.→ 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어가 굳이 다를 이유가 없다.

// ## 고립형 입출력 /////////////////////////////////////////

// 고립형 입출력은 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법이다.

// 가령 1024개의 주소 공간을 가지고 있는 컴퓨터라 가정했을 때, 제어 버스를 ‘메모리 읽기 / 쓰기’ 선 이외의 ‘입출력장치 읽기 / 쓰기’ 선을 추가하면 메모리에도 1024개의 주소 공간을, 입출력장치도 1024개의 주소 공간을 활용할 수 있다.

// 고립형 입출력 방식에서 CPU는 입출력장치에 접근하기 위해 메모리에 접근하는 명령어와 다른(입출력 읽기 / 쓰기 선을 활성화시키는) 입출력 명령어를 사용한다.

//////////////////////////////////////////////////////////

// [ 인터럽트 기반 입출력 ] /////////////////////////////////

// 입출력장치에 의한 하드웨어 인터럽트는 정확히 말하면 입출력장치가 아닌 장치 컨트롤러에 의해 발생한다.

// 장치 컨트롤러가 입출력 작업을 끝낸 후 CPU에게 인터럽트 요청 신호를 보내면 CPU는 하던 일을 잠시 백업하고 인터럽트 서비스 루틴을 실행한다.

// 이렇게 인터럽트를 기반으로 하는 입출력을 인터럽트 기반 입출력이라 한다.


// 폴링 ---------------------------------------------------

// 폴링이란 입출력장치의 상태는 어떤지, 처리할 데이터가 있는지 주기적으로 확인하는 방식이다.← 인터럽트 방식보다 CPU의 부담이 더 크다.

// 앞서 나온 프로그램 입출력 방식이 폴링 방식을 사용한다.
// --------------------------------------------------------

//////////////////////////////////////////////////////////

// 인터럽트가 동시에 발생했을 경우 이를 처리하는 방법으로 간단하게 생각하면 인터럽트가 발생한 순서대로 이를 처리하는 방법이 있다.← 하지만 인터럽트 중에서도 빨리 처리해야 하는 인터럽트가 있기 때문에 현실적으로 불가능한 방법이다.

// → 즉, CPU는 인터럽트 간의 우선순위를 고려하여 우선순위가 높은 인터럽트 순으로 여러 인터럽트를 처리할 수 있어야 한다.

// NMI: 플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우, 혹은 인터럽트 비트가 비활성화해도 무시할 수 없는 인터럽트이다.← 발생할 경우 CPU는 우선 순위가 높은 인터럽트부터 처리한다.

// 우선순위를 반영하여 다중 인터럽트를 처리하는 많은 방법 중, 많은 컴퓨터들은 프로그래머블 인터럽트 컨트롤러(PIC)라는 하드웨어를 사용한다.

// PIC는 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에 지금 처리해야 할 하드웨어 인터럽트가 무엇인지 알려주는 장치이다.

// PIC가 다중 인터럽트를 처리하는 과정

// 1. PIC가 장치 컨트롤러에서 인터럽트 요청 신호를 받아들인다.
// 2. PIC는 인터럽트 우선순위를 판별한 뒤 CPU에 처리해야 할 인터럽트 요청 신호를 보낸다.
// 3. CPU는 PIC의 인터럽트 확인 요청 신호를 확인한다.
// 4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 전송한다.
// 5. CPU는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게 되고, 해당 장치의 인터럽트 서비스 루틴을 실행한다.

// 참고로 PIC가 무시할 수 없는 인터럽트인 NMI까지 우선순위를 판별하진 않는다.

// PIC가 우선순위를 조정해 주는 인터럽트는 인터럽트 비트를 통해 막을 수 있는 하드웨어 인터럽트이다.

//////////////////////////////////////////////////////////

// [ DMA 입출력 ] /////////////////////////////////////////

// 프로그램 기반 입출력과 인터럽트 기반 입출력 모두 인출력장치와 메모리 간의 데이터 이동은 CPU가 주도하고, 이동하는 데이터도 반드시 CPU를 거친다.

// CPU 부담을 줄이기 위해 입출력장치와 메모리가 CPU를 거치지 않고도 상호작용할 수 있는 입출력 방식인 DMA가 등장했다.

// DMA는 직접 메모리에 접근할 수 있는 입출력 기능으로 이를 위해서는 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요하다.

//////////////////////////////////////////////////////////

// DMA 입출력 과정

// 1. CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산, 읽거나 쓸 메모리의 주소 등의 같은 정보로 입출력 작업을 명령한다.

// 2. DMA  컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다.
// 이때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 쓴다.

// 3. 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알린다.

// DMA 방식에서 CPU는 오로지 입출력의 시작과 끝에만 관여하면 된다.

// DMA 컨트롤러는 시스템 버스로 메모리를 직접 접근이 가능하지만, 시스템 버스는 동시에 사용이 불가능하다. (공용 자원이라)

// → DMA 컨트롤러는 CPU가 시스템 버스를 사용하지 않을 때마다 조금씩 이용하거나, CPU가 일시적으로 시스템 버스를 사용하지 않도록 허락을 구하고 시스템 버스를 집중적으로 이용한다.

//////////////////////////////////////////////////////////

// DMA 컨트롤러가 데이터를 가져올 때, 데이터를 장치 컨트롤러로 옮길 때 시스템 버스를 이용한다.DMA를 위해 시스템 버스를 자주 사용하면 그만큼 CPU가 시스템 버스를 이용하지 못한다.

// 이러한 문제는 DMA  컨트롤러와 장치 컨트롤러들이 사용하는 입출력 버스라는 별도의 버스 연결을 통해 해결할 수 있다.

// 대부분의 입출력장치(장치 컨트롤러)는 시스템 버스가 아닌 입출력 버스와 연결된다.


// 입출력 채널 ---------------------------------------------

// 여전히 인출하고, 해석하고, 실행하는 역할의 상당 부분이 CPU의 몫이다.

// 이러한 문제를 해결하기 위해 최근에는 메모리에 접근할 뿐만 아니라 인출하고, 해석하고, 실행까지 하는, 일종의 입출력 전용 CPU가 만들어졌다.

// → 이를 입출력 프로세서 혹은 입출력 채널이라 부른다.

// 현재 일부 최신 입출력장치 내부에는 이러한 별도의 CPU가 포함되어 있다.

// --------------------------------------------------------


// 정리 ---------------------------------------------------
// - 프로그램 입출력은 프로그램 속 명령어로 입출력 작업을 하는 방식이다.
// - 메모리 맵 입출력은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 입출력 방식이다.
// - 고립형 입출력은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 별도로 분리하는 입출력 방식이다.
// - 인터럽트 기반 입출력은 인터럽트로써 입출력을 수행하는 방법이다.
// - DMA 입출력은 CPU를 거치지 않고 메모리와 입출력장치 간의 데이터를 주고받는 입출력 방식이다.
// - 입출력 버스는 입출력장치와 컴퓨터 내부를 연결 짓는 통로로, 입출력 작업 과정에서 시스템 버스 사용 횟수를 줄여준다.
// --------------------------------------------------------